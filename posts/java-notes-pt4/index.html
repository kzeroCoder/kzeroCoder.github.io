<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java杂记——数组和双轴排序 | kzeroCoder</title><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Java杂记——数组和双轴排序" /><meta name="author" content="Kzero Coder" /><meta property="og:locale" content="en_US" /><meta name="description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><meta property="og:description" content="A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation." /><link rel="canonical" href="https://kzerocoder.github.io/posts/java-notes-pt4/" /><meta property="og:url" content="https://kzerocoder.github.io/posts/java-notes-pt4/" /><meta property="og:site_name" content="kzeroCoder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-29T10:30:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java杂记——数组和双轴排序" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Kzero Coder" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.","@type":"BlogPosting","headline":"Java杂记——数组和双轴排序","dateModified":"2021-05-29T10:30:00+08:00","datePublished":"2021-05-29T10:30:00+08:00","url":"https://kzerocoder.github.io/posts/java-notes-pt4/","mainEntityOfPage":{"@type":"WebPage","@id":"https://kzerocoder.github.io/posts/java-notes-pt4/"},"author":{"@type":"Person","name":"Kzero Coder"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">kzeroCoder</a></div><div class="site-subtitle font-italic">No learning, long life</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/kzeroCoder" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['example','doamin.com'].join('@'))" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Java杂记——数组和双轴排序</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java杂记——数组和双轴排序</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, May 29, 2021, 10:30 AM +0800" > May 29 <i class="unloaded">2021-05-29T10:30:00+08:00</i> </span> by <span class="author"> Kzero Coder </span></div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, May 31, 2021, 10:40 AM +0800" > May 31 <i class="unloaded">2021-05-31T10:40:44+08:00</i> </span></div></div><div class="post-content"><head> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } }); </script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"> </script><h1 id="数组">数组</h1><h2 id="一维数组">一维数组</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">//数组声明</span>
<span class="n">dataType</span><span class="o">[]</span> <span class="n">arrayRefVar</span><span class="o">;</span>	<span class="c1">//首选方法</span>
<span class="n">dataType</span> <span class="n">arrayRefVar</span><span class="o">[];</span>	<span class="c1">//效果相同，但是不推荐</span>

<span class="c1">//创建数组</span>
<span class="n">arrayRefVar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">dataType</span><span class="o">[</span><span class="n">arraySize</span><span class="o">];</span>	<span class="c1">//初始化默认为dataType的default值</span>
<span class="n">dataType</span><span class="o">[]</span> <span class="n">arrayRefVar</span> <span class="o">=</span> <span class="o">{</span><span class="n">value0</span><span class="o">,</span> <span class="n">value1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">valuek</span><span class="o">};</span>	<span class="c1">//创建的同时初始化，为静态定义</span>

<span class="c1">//数组长度</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arrayRefVar</span><span class="o">.</span><span class="na">length</span>	<span class="c1">//注意数组的length是一个属性，但是String的length是一个方法</span>
</pre></table></code></div></div><h2 id="多维数组">多维数组</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">//数组声明</span>
<span class="n">dataType</span><span class="o">[][]</span> <span class="n">arrayRefVar</span><span class="o">;</span>

<span class="c1">//创建数组和一维数组类似</span>

<span class="c1">//数组长度</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arrayTest</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>	<span class="c1">//获取的是一维数组的数量，即第一维的个数</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">arrayTest</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>	<span class="c1">//获取的是第一个一维数组的长度，以dataType[][] arrayTest = new dataType[value0][value1]定义时为value1</span>
<span class="cm">/*ps:其实记多维数组只是为了这个多维数组的长度而已。。。。。*/</span>
</pre></table></code></div></div><h2 id="arrays类">Arrays类</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
</pre><td class="rouge-code"><pre>	<span class="cm">/**
     * The minimum array length below which a parallel sorting
     * algorithm will not further partition the sorting task. Using
     * smaller sizes typically results in memory contention across
     * tasks that makes parallel speedups unlikely.
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_ARRAY_SORT_GRAN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="o">;</span>	<span class="c1">//也就是最小的能够使用并行处理的数组长度</span>

	<span class="cm">/**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */</span>
	<span class="c1">// 升序排序特定数组</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DualPivotQuicksort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>	<span class="c1">//Java排序使用的是双轴快排，而不是普通的快排</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Sorts the specified range of the array into ascending order. The range
     * to be sorted extends from the index {@code fromIndex}, inclusive, to
     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
     * the range to be sorted is empty.
     *
     * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     */</span>
	<span class="c1">// 排序特定范围内[fromIndex, toIndex)的数组</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rangeCheck</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span><span class="o">);</span>
        <span class="nc">DualPivotQuicksort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>


	<span class="c1">//在1.8后，Java支持了并行排序，使用的是ArraysParallelSortHelpers类</span>
	<span class="cm">/**
     * Sorts the specified array into ascending numerical order.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parallelSort</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="no">MIN_ARRAY_SORT_GRAN</span> <span class="o">||</span>
            <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">getCommonPoolParallelism</span><span class="o">())</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="nc">DualPivotQuicksort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="k">new</span> <span class="nc">ArraysParallelSortHelpers</span><span class="o">.</span><span class="na">FJByte</span><span class="o">.</span><span class="na">Sorter</span>
                <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">n</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
                 <span class="o">((</span><span class="n">g</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="o">(</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="o">))</span> <span class="o">&lt;=</span> <span class="no">MIN_ARRAY_SORT_GRAN</span><span class="o">)</span> <span class="o">?</span>
                 <span class="no">MIN_ARRAY_SORT_GRAN</span> <span class="o">:</span> <span class="n">g</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index {@code fromIndex},
     * inclusive, to the index {@code toIndex}, exclusive. If
     * {@code fromIndex == toIndex}, the range to be sorted is empty.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate {@link
     * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
     *
     * @since 1.8
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">parallelSort</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rangeCheck</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">toIndex</span> <span class="o">-</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="no">MIN_ARRAY_SORT_GRAN</span> <span class="o">||</span>
            <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">getCommonPoolParallelism</span><span class="o">())</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="nc">DualPivotQuicksort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="k">new</span> <span class="nc">ArraysParallelSortHelpers</span><span class="o">.</span><span class="na">FJByte</span><span class="o">.</span><span class="na">Sorter</span>
                <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">n</span><span class="o">],</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
                 <span class="o">((</span><span class="n">g</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="o">(</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="o">))</span> <span class="o">&lt;=</span> <span class="no">MIN_ARRAY_SORT_GRAN</span><span class="o">)</span> <span class="o">?</span>
                 <span class="no">MIN_ARRAY_SORT_GRAN</span> <span class="o">:</span> <span class="n">g</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
    <span class="o">}</span>
	
	<span class="c1">//并行堆叠，其实就是是一个从前往后做加法的运算</span>
	<span class="cm">/**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds {@code [2, 1, 0, 3]} and the operation performs addition,
     * then upon return the array holds {@code [2, 3, 3, 6]}.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">parallelPrefix</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">op</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">new</span> <span class="nc">ArrayPrefixHelpers</span><span class="o">.</span><span class="na">CumulateTask</span><span class="o">&lt;&gt;</span>
                    <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">op</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Performs {@link #parallelPrefix(Object[], BinaryOperator)}
     * for the given subrange of the array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
     * @throws ArrayIndexOutOfBoundsException
     *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; array.length}
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">parallelPrefix</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span>
                                          <span class="kt">int</span> <span class="n">toIndex</span><span class="o">,</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">op</span><span class="o">);</span>
        <span class="n">rangeCheck</span><span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fromIndex</span> <span class="o">&lt;</span> <span class="n">toIndex</span><span class="o">)</span>
            <span class="k">new</span> <span class="nc">ArrayPrefixHelpers</span><span class="o">.</span><span class="na">CumulateTask</span><span class="o">&lt;&gt;</span>
                    <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">op</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
    <span class="o">}</span>
	
	<span class="c1">//fill，顾名思义，就是用来填充数组的，可以全填充，也可以部分填充，但是需要连续</span>
	<span class="cm">/**
     * Assigns the specified Object reference to each element of the specified
     * array of Objects.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     * @throws ArrayStoreException if the specified value is not of a
     *         runtime type that can be stored in the specified array
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">fill</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Assigns the specified Object reference to each element of the specified
     * range of the specified array of Objects.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     * @throws ArrayStoreException if the specified value is not of a
     *         runtime type that can be stored in the specified array
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">fill</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rangeCheck</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="n">toIndex</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">fromIndex</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">toIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
	
	<span class="c1">//copy，没什么好说的</span>
	<span class="cm">/**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;(byte)0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">copyOf</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">original</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newLength</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">newLength</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">copy</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
                         <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">newLength</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>

	<span class="cm">/**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;(byte)0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if {@code from &lt; 0}
     *     or {@code from &gt; original.length}
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">copyOfRange</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">original</span><span class="o">,</span> <span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">newLength</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">newLength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">from</span> <span class="o">+</span> <span class="s">" &gt; "</span> <span class="o">+</span> <span class="n">to</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">newLength</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">copy</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
                         <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">from</span><span class="o">,</span> <span class="n">newLength</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>

	<span class="c1">//ArrayList是由数组实现的</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="nc">RandomAccess</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span><span class="o">{...}</span>
    
	<span class="c1">//哈希化通过计算数值决定（真的不会出冲突么？？）</span>
     <span class="cm">/**
     * Returns a hash code based on the contents of the specified array.  If
     * the array contains other arrays as elements, the hash code is based on
     * their identities rather than their contents.  It is therefore
     * acceptable to invoke this method on an array that contains itself as an
     * element,  either directly or indirectly through one or more levels of
     * arrays.
     *
     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
     * &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is equal to the value that would
     * be returned by &lt;tt&gt;Arrays.asList(a).hashCode()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;0&lt;/tt&gt; is returned.
     *
     * @param a the array whose content-based hash code to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @see #deepHashCode(Object[])
     * @since 1.5
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="nc">Object</span> <span class="n">a</span><span class="o">[])</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">element</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">element</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">element</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

	<span class="c1">//deepEquals和deepHashCode只不过适配了Object[]类型的相等比较，其余差别不大</span>

	<span class="c1">//Arrays类支持mergeSort和binarySort，用法和sort差不多，此处未列出</span>
</pre></table></code></div></div><p><em>注：数组range操作都是左闭右开的</em></p><h2 id="dualpivotquicksort">DualPivotQuicksort</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
</pre><td class="rouge-code"><pre>	<span class="c1">//使用给定空间排序，如果空间足够，则采用merge，左闭右闭</span>
    <span class="cm">/**
     * Sorts the specified range of the array using the given
     * workspace array slice if possible for merging
     *
     * @param a the array to be sorted
     * @param left the index of the first element, inclusive, to be sorted
     * @param right the index of the last element, inclusive, to be sorted
     * @param work a workspace array (slice)
     * @param workBase origin of usable space in work array
     * @param workLen usable size of work array
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span>
                     <span class="kt">int</span><span class="o">[]</span> <span class="n">work</span><span class="o">,</span> <span class="kt">int</span> <span class="n">workBase</span><span class="o">,</span> <span class="kt">int</span> <span class="n">workLen</span><span class="o">)</span> <span class="o">{</span>
       	<span class="c1">//小数组直接使用快排</span>
        <span class="c1">// Use Quicksort on small arrays</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="no">QUICKSORT_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/*
         * Index run[i] is the start of i-th run
         * (ascending or descending sequence).
         */</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">run</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">MAX_RUN_COUNT</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">run</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>

        <span class="c1">// 将部分递增序列和递减序列提前排序，并记录趟数和趟数开始地址，用于后续归并排序</span>
        <span class="c1">// Check if the array is nearly sorted</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="n">run</span><span class="o">[</span><span class="n">count</span><span class="o">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// ascending</span>
                <span class="k">while</span> <span class="o">(++</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// descending</span>
                <span class="k">while</span> <span class="o">(++</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]);</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">run</span><span class="o">[</span><span class="n">count</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="o">--</span><span class="n">hi</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">hi</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">hi</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// equal</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="no">MAX_RUN_LENGTH</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span> <span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(--</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
			
            <span class="c1">// 如果数组足够混乱，趟数超过一定数量，就分区进行快排</span>
            <span class="cm">/*
             * The array is not highly structured,
             * use Quicksort instead of merge sort.
             */</span>
            <span class="k">if</span> <span class="o">(++</span><span class="n">count</span> <span class="o">==</span> <span class="no">MAX_RUN_COUNT</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Check special cases</span>
        <span class="c1">// Implementation note: variable "right" is increased by 1.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">run</span><span class="o">[</span><span class="n">count</span><span class="o">]</span> <span class="o">==</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// The last run contains one element</span>
            <span class="n">run</span><span class="o">[++</span><span class="n">count</span><span class="o">]</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// The array is already sorted</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
		
        <span class="c1">// 后续是使用缓冲区进行归并排序，不进行解释</span>
        <span class="c1">// Determine alternation base for merge</span>
        <span class="kt">byte</span> <span class="n">odd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">odd</span> <span class="o">^=</span> <span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Use or create temporary array b for merging</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">;</span>                 <span class="c1">// temp array; alternates with a</span>
        <span class="kt">int</span> <span class="n">ao</span><span class="o">,</span> <span class="n">bo</span><span class="o">;</span>              <span class="c1">// array offsets from 'left'</span>
        <span class="kt">int</span> <span class="n">blen</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span> <span class="c1">// space needed for b</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">work</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">workLen</span> <span class="o">&lt;</span> <span class="n">blen</span> <span class="o">||</span> <span class="n">workBase</span> <span class="o">+</span> <span class="n">blen</span> <span class="o">&gt;</span> <span class="n">work</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">work</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">blen</span><span class="o">];</span>
            <span class="n">workBase</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">odd</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">work</span><span class="o">,</span> <span class="n">workBase</span><span class="o">,</span> <span class="n">blen</span><span class="o">);</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">work</span><span class="o">;</span>
            <span class="n">ao</span> <span class="o">=</span> <span class="n">workBase</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">work</span><span class="o">;</span>
            <span class="n">ao</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="n">workBase</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Merging</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">last</span><span class="o">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">;</span> <span class="n">count</span> <span class="o">=</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="o">(</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">run</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">run</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">run</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="o">],</span> <span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mi</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="n">hi</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">mi</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">ao</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">q</span> <span class="o">+</span> <span class="n">ao</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">b</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">bo</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">p</span><span class="o">++</span> <span class="o">+</span> <span class="n">ao</span><span class="o">];</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">b</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">bo</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">q</span><span class="o">++</span> <span class="o">+</span> <span class="n">ao</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">run</span><span class="o">[++</span><span class="n">last</span><span class="o">]</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="o">,</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">run</span><span class="o">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">lo</span><span class="o">;</span>
                    <span class="n">b</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">bo</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">ao</span><span class="o">]</span>
                <span class="o">);</span>
                <span class="n">run</span><span class="o">[++</span><span class="n">last</span><span class="o">]</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">o</span> <span class="o">=</span> <span class="n">ao</span><span class="o">;</span> <span class="n">ao</span> <span class="o">=</span> <span class="n">bo</span><span class="o">;</span> <span class="n">bo</span> <span class="o">=</span> <span class="n">o</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Sorts the specified range of the array by Dual-Pivot Quicksort.
     *
     * @param a the array to be sorted
     * @param left the index of the first element, inclusive, to be sorted
     * @param right the index of the last element, inclusive, to be sorted
     * @param leftmost indicates if this part is the leftmost in the range
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">leftmost</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
		
        <span class="c1">// 对小数组使用插入排序，源码给的数为47</span>
        <span class="c1">// Use insertion sort on tiny arrays</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="no">INSERTION_SORT_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftmost</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/*
                 * Traditional (without sentinel) insertion sort,
                 * optimized for server VM, is used in case of
                 * the leftmost part.
                 */</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="n">j</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">ai</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">ai</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">--</span> <span class="o">==</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ai</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="cm">/*
                 * Skip the longest ascending sequence.
                 */</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[++</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>

                <span class="cm">/*
                 * Every element from adjoining part plays the role
                 * of sentinel, therefore this allows us to avoid the
                 * left range check on each iteration. Moreover, we use
                 * the more optimized algorithm, so called pair insertion
                 * sort, which is faster (in the context of Quicksort)
                 * than traditional implementation of insertion sort.
                 */</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="o">++</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">k</span> <span class="o">=</span> <span class="o">++</span><span class="n">left</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">a1</span> <span class="o">&lt;</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">a1</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[--</span><span class="n">k</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="n">a</span><span class="o">[++</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a1</span><span class="o">;</span>

                    <span class="k">while</span> <span class="o">(</span><span class="n">a2</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[--</span><span class="n">k</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

                <span class="k">while</span> <span class="o">(</span><span class="n">last</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[--</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="n">a</span><span class="o">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Inexpensive approximation of length / 7</span>
        <span class="kt">int</span> <span class="n">seventh</span> <span class="o">=</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="cm">/*
         * Sort five evenly spaced elements around (and including) the
         * center element in the range. These elements will be used for
         * pivot selection as described below. The choice for spacing
         * these elements was empirically determined to work well on
         * a wide variety of inputs.
         */</span>
        <span class="kt">int</span> <span class="n">e3</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// The midpoint</span>
        <span class="kt">int</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">e3</span> <span class="o">-</span> <span class="n">seventh</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">seventh</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">e4</span> <span class="o">=</span> <span class="n">e3</span> <span class="o">+</span> <span class="n">seventh</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">e5</span> <span class="o">=</span> <span class="n">e4</span> <span class="o">+</span> <span class="n">seventh</span><span class="o">;</span>

        <span class="c1">// Sort these elements using insertion sort</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">])</span> <span class="o">{</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">])</span> <span class="o">{</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">])</span> <span class="o">{</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">])</span> <span class="o">{</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">])</span> <span class="o">{</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">])</span> <span class="o">{</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">e5</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">])</span> <span class="o">{</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e5</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e5</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">])</span> <span class="o">{</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">])</span> <span class="o">{</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">])</span> <span class="o">{</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Pointers</span>
        <span class="kt">int</span> <span class="n">less</span>  <span class="o">=</span> <span class="n">left</span><span class="o">;</span>  <span class="c1">// The index of the first element of center part</span>
        <span class="kt">int</span> <span class="n">great</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span> <span class="c1">// The index before the first element of right part</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">e1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">[</span><span class="n">e5</span><span class="o">])</span> <span class="o">{</span>
            <span class="cm">/*
             * Use the second and fourth of the five sorted elements as pivots.
             * These values are inexpensive approximations of the first and
             * second terciles of the array. Note that pivot1 &lt;= pivot2.
             */</span>
            <span class="kt">int</span> <span class="n">pivot1</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">pivot2</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">];</span>

            <span class="cm">/*
             * The first and the last elements to be sorted are moved to the
             * locations formerly occupied by the pivots. When partitioning
             * is complete, the pivots are swapped back into their final
             * positions, and excluded from subsequent sorting.
             */</span>
            <span class="n">a</span><span class="o">[</span><span class="n">e2</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="n">a</span><span class="o">[</span><span class="n">e4</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="cm">/*
             * Skip elements, which are less or greater than pivot values.
             */</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[++</span><span class="n">less</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot1</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[--</span><span class="n">great</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot2</span><span class="o">);</span>

            <span class="cm">/*
             * Partitioning:
             *
             *   left part           center part                   right part
             * +--------------------------------------------------------------+
             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              less                        k     great
             *
             * Invariants:
             *
             *              all in (left, less)   &lt; pivot1
             *    pivot1 &lt;= all in [less, k)     &lt;= pivot2
             *              all in (great, right) &gt; pivot2
             *
             * Pointer k is the first index of ?-part.
             */</span>
            <span class="nl">outer:</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">less</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">great</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ak</span> <span class="o">&lt;</span> <span class="n">pivot1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Move a[k] to left part</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">];</span>
                    <span class="cm">/*
                     * Here and below we use "a[i] = b; i++;" instead
                     * of "a[i++] = b;" due to performance issue.
                     */</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">;</span>
                    <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ak</span> <span class="o">&gt;</span> <span class="n">pivot2</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Move a[k] to right part</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot2</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">great</span><span class="o">--</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">break</span> <span class="n">outer</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// a[great] &lt;= pivot2</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">];</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">];</span>
                        <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// pivot1 &lt;= a[great] &lt;= pivot2</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="cm">/*
                     * Here and below we use "a[i] = b; i--;" instead
                     * of "a[i--] = b;" due to performance issue.
                     */</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">;</span>
                    <span class="o">--</span><span class="n">great</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Swap pivots into their final positions</span>
            <span class="n">a</span><span class="o">[</span><span class="n">left</span><span class="o">]</span>  <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span>  <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span>  <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot1</span><span class="o">;</span>
            <span class="n">a</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">great</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> <span class="n">a</span><span class="o">[</span><span class="n">great</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot2</span><span class="o">;</span>

            <span class="c1">// Sort left and right parts recursively, excluding known pivots</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">less</span> <span class="o">-</span> <span class="mi">2</span><span class="o">,</span> <span class="n">leftmost</span><span class="o">);</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">great</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

            <span class="cm">/*
             * If center part is too large (comprises &gt; 4/7 of the array),
             * swap internal pivot values to ends.
             */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">less</span> <span class="o">&lt;</span> <span class="n">e1</span> <span class="o">&amp;&amp;</span> <span class="n">e5</span> <span class="o">&lt;</span> <span class="n">great</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/*
                 * Skip elements, which are equal to pivot values.
                 */</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">==</span> <span class="n">pivot1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">==</span> <span class="n">pivot2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">--</span><span class="n">great</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="cm">/*
                 * Partitioning:
                 *
                 *   left part         center part                  right part
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             less                      k     great
                 *
                 * Invariants:
                 *
                 *              all in (*,  less) == pivot1
                 *     pivot1 &lt; all in [less,  k)  &lt; pivot2
                 *              all in (great, *) == pivot2
                 *
                 * Pointer k is the first index of ?-part.
                 */</span>
                <span class="nl">outer:</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">less</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">great</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">ak</span> <span class="o">==</span> <span class="n">pivot1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Move a[k] to left part</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">];</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">;</span>
                        <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ak</span> <span class="o">==</span> <span class="n">pivot2</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Move a[k] to right part</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">==</span> <span class="n">pivot2</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">great</span><span class="o">--</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">break</span> <span class="n">outer</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">==</span> <span class="n">pivot1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// a[great] &lt; pivot2</span>
                            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">];</span>
                            <span class="cm">/*
                             * Even though a[great] equals to pivot1, the
                             * assignment a[less] = pivot1 may be incorrect,
                             * if a[great] and pivot1 are floating-point zeros
                             * of different signs. Therefore in float and
                             * double sorting methods we have to use more
                             * accurate assignment a[less] = a[great].
                             */</span>
                            <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot1</span><span class="o">;</span>
                            <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// pivot1 &lt; a[great] &lt; pivot2</span>
                            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">];</span>
                        <span class="o">}</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">;</span>
                        <span class="o">--</span><span class="n">great</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Sort center part recursively</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">less</span><span class="o">,</span> <span class="n">great</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// Partitioning with one pivot</span>
            <span class="cm">/*
             * Use the third of the five sorted elements as pivot.
             * This value is inexpensive approximation of the median.
             */</span>
            <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">e3</span><span class="o">];</span>

            <span class="cm">/*
             * Partitioning degenerates to the traditional 3-way
             * (or "Dutch National Flag") schema:
             *
             *   left part    center part              right part
             * +-------------------------------------------------+
             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             less            k      great
             *
             * Invariants:
             *
             *   all in (left, less)   &lt; pivot
             *   all in [less, k)     == pivot
             *   all in (great, right) &gt; pivot
             *
             * Pointer k is the first index of ?-part.
             */</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">less</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">great</span><span class="o">;</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="kt">int</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ak</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Move a[k] to left part</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">];</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">;</span>
                    <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// a[k] &gt; pivot - Move a[k] to right part</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                        <span class="o">--</span><span class="n">great</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// a[great] &lt;= pivot</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">];</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">less</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">];</span>
                        <span class="o">++</span><span class="n">less</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// a[great] == pivot</span>
                        <span class="cm">/*
                         * Even though a[great] equals to pivot, the
                         * assignment a[k] = pivot may be incorrect,
                         * if a[great] and pivot are floating-point
                         * zeros of different signs. Therefore in float
                         * and double sorting methods we have to use
                         * more accurate assignment a[k] = a[great].
                         */</span>
                        <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">a</span><span class="o">[</span><span class="n">great</span><span class="o">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">;</span>
                    <span class="o">--</span><span class="n">great</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="cm">/*
             * Sort left and right parts recursively.
             * All elements from center part are equal
             * and, therefore, already sorted.
             */</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">less</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">leftmost</span><span class="o">);</span>
            <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">great</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="双轴快速排序">双轴快速排序</h3><ol><li><p>选择两个点P1，P2作为轴心</p></li><li><p>P1必须小于P2，否则将P1和P2进行交换</p></li><li><p>将数组分为4部分：</p><ul><li>比P1小的元素</li><li>比P1大，比P2小的元素</li><li>比P2大的元素</li><li>未比较的元素</li></ul><p>开始比较前，除了轴点，其余元素都在第四部分</p></li><li><p>从第四部分选择a[K]，与两轴心比较，放到其余三部分中</p></li><li><p>移动L，K，G指向</p></li><li><p>重复4，5直到第四部分没有元素</p></li><li><p>将P1与第一部分的最后一个元素交换。将P2与第三部分的第一个元素交换。</p></li><li><p>递归排序第一二三部分</p></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/img/javaNotes/20140118232211015.jpg" alt="img" /></p><p><em>注：双轴排序源自https://blog.csdn.net/xjyzxx/article/details/18465661</em></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/javanotes/'>JavaNotes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/writing/" class="post-tag no-text-decoration" >writing</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Java杂记——数组和双轴排序 - kzeroCoder&url=https://kzeroCoder.github.io/posts/java-notes-pt4/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Java杂记——数组和双轴排序 - kzeroCoder&u=https://kzeroCoder.github.io/posts/java-notes-pt4/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Java杂记——数组和双轴排序 - kzeroCoder&url=https://kzeroCoder.github.io/posts/java-notes-pt4/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/java-notes-pt3/">Java杂记——StringBuilder，Comparator和Comparable</a></li><li><a href="/posts/java-notes-pt4/">Java杂记——数组和双轴排序</a></li><li><a href="/posts/java-notes-pt1/">Java杂记——容器</a></li><li><a href="/posts/machine-learning-ch1/">机器学习笔记(一)</a></li><li><a href="/posts/machine-learning-ch4/">机器学习笔记(四)</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/typography/">typography</a> <a class="post-tag" href="/tags/writing/">writing</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-notes-pt1/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > May 28 <i class="unloaded">2021-05-28T11:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java杂记——容器</h3><div class="text-muted small"><p> 容器 绿色为接口，黄色为抽象类，蓝色为类，灰线和黑线没有区别，只是用来防止交错的时候产生误导，线上i表示implements，e表示extends Collection The root interface in the collection hierarchy. A collection represents a group of obj...</p></div></div></a></div><div class="card"> <a href="/posts/java-notes-pt2/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > May 28 <i class="unloaded">2021-05-28T11:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java杂记——设计模式</h3><div class="text-muted small"><p> 设计模式 Design Pattern 本文参考https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528 仅作个人摘记，学习建议前往原网站 创建型模式 工厂方法 Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类 目的是使得创...</p></div></div></a></div><div class="card"> <a href="/posts/java-notes-pt3/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > May 29 <i class="unloaded">2021-05-29T08:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java杂记——StringBuilder，Comparator和Comparable</h3><div class="text-muted small"><p> StringBuilder类 public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence StringBuilder实质上是一个CharSequence，即字符数组char[] ...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-notes-pt3/" class="btn btn-outline-primary"><p>Java杂记——StringBuilder，Comparator和Comparable</p></a> <span class="btn btn-outline-primary disabled"><p>-</p></span></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">kzeroCoder</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/typography/">typography</a> <a class="post-tag" href="/tags/writing/">writing</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://kzeroCoder.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
